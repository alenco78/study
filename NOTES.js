//
// sort es nlogn
// Cuando se compara desde el 2do elemento de un array, usar en el for i=1; i<arr.length
// Cuando es desde cero, usar i=0; i< arr.length-1 

// Para la suma de todos los numeros hasta n =
// ( n * (n+1)) / 2

// sort array of numbers
// arr.sort((a,b) =: a-b)

// sort intervals 
// intervals.sort((a,b) => a[0]- b[0])

// binary search for log(n) complexity

// bFs recorre o busca nodos de un grafo

// const map = new Map() ------> Conserva el orden en el que se insertan las llaves valor
// this.map.get(key) -------> Obtienen una llave
// this.map.delete(key) ----> Borra una llave
// this.map.set(key, value)-> Agrega llave-valor al final
// this.map.size

// En una matriz bidimensional cuadrada:
// matrix rows = matrix.length
// matrix cols = matrix[0].length

// Para crear una tabla vacía:
// let result = Array.from({ length: rows }, () => Array(cols).fill(0));

// Se puede definir un hash como {}
// Insertar valores como hash[value] = value2;

// Cuando sorted array, pensar en binary search

// Cuando los valores de un array [1-n]
// se puede usar el valor apuntando al idx del arr
// cambiar el value a negativo y si se vuelve a scanear,
// el value es duplicado

// El mínimo entre 2 valores Math.min(height[left], height[right])
// El máximo entre 2 valores Math.max(-10, -1)